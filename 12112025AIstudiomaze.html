<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Nebula Maze: Fog of War</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Babel Standalone for JSX/TSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    body { touch-action: none; } /* Prevent pull-to-refresh on mobile */
  </style>

  <!-- Polyfill for process.env -->
  <script>
    window.process = { env: { API_KEY: '' } };
  </script>

  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0?external=react,react-dom",
    "recharts": "https://esm.sh/recharts@2.12.0?external=react,react-dom",
    "@google/genai": "https://esm.sh/@google/genai"
  }
}
</script>

  <script type="text/babel" data-type="module" data-presets="typescript,react">
    import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
    import { createRoot } from 'react-dom/client';
    import { 
      ArrowUp, ArrowDown, ArrowLeft, ArrowRight, 
      Map as MapIcon, Shield, RefreshCw, Sparkles, AlertTriangle, User, Skull 
    } from 'lucide-react';
    import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
    import { GoogleGenAI } from '@google/genai';

    // --- TYPES ---
    const Direction = {
      N: 1,
      E: 2,
      S: 4,
      W: 8,
    };

    const ItemType = {
      Start: 'start',
      Exit: 'exit',
      Health: 'health',
      Score: 'score',
      Hazard: 'hazard',
      Weapon: 'weapon',
      Empty: 'empty'
    };

    // --- CONSTANTS ---
    const VISIBILITY_RADIUS = 1;

    const LEVEL_CONFIG = {
      1: { w: 10, h: 10 },
      2: { w: 15, h: 15 },
      3: { w: 20, h: 20 },
      4: { w: 25, h: 25 },
    };

    const ITEMS_CONFIG = {
      [ItemType.Health]: { char: 'üíä', color: 'text-red-500', name: 'Health Pack' },
      [ItemType.Score]: { char: 'üíé', color: 'text-cyan-400', name: 'Gem' },
      [ItemType.Hazard]: { char: 'üêç', color: 'text-green-600', name: 'Snake' },
      [ItemType.Weapon]: { char: 'üó°Ô∏è', color: 'text-slate-300', name: 'Dagger' },
      [ItemType.Exit]: { char: 'üö™', color: 'text-yellow-500', name: 'Exit' },
      [ItemType.Start]: { char: 'S', color: 'text-white', name: 'Start' },
      [ItemType.Empty]: { char: '', color: '', name: '' },
    };

    // --- AUDIO SERVICE ---
    const playSound = (type) => {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) return;

      const ctx = new AudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      const now = ctx.currentTime;

      switch (type) {
        case 'step':
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(100, now);
          osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
          gain.gain.setValueAtTime(0.05, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
          osc.start(now);
          osc.stop(now + 0.05);
          break;

        case 'bump':
          osc.type = 'square';
          osc.frequency.setValueAtTime(100, now);
          osc.frequency.linearRampToValueAtTime(80, now + 0.1);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
          osc.start(now);
          osc.stop(now + 0.1);
          break;

        case 'pickup':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(600, now);
          osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
          osc.start(now);
          osc.stop(now + 0.15);
          break;

        case 'hazard':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(200, now);
          osc.frequency.linearRampToValueAtTime(50, now + 0.3);
          gain.gain.setValueAtTime(0.2, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
          break;

        case 'levelUp':
          osc.type = 'triangle';
          [440, 554, 659, 880].forEach((freq, i) => {
            const t = now + i * 0.1;
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'triangle';
            o.connect(g);
            g.connect(ctx.destination);
            o.frequency.value = freq;
            g.gain.setValueAtTime(0.1, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            o.start(t);
            o.stop(t + 0.3);
          });
          break;
          
        case 'die':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
            osc.start(now);
            osc.stop(now + 1);
            break;
      }
    };

    // --- GEMINI SERVICE ---
    const apiKey = process.env.API_KEY || '';
    const ai = apiKey ? new GoogleGenAI({ apiKey }) : null;

    const generateFlavorText = async (level, hp) => {
      if (!ai) return "The dungeon is silent. (No API Key)";

      try {
        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: `Write a single, short, atmospheric sentence (max 15 words) describing a dungeon level ${level}. The player has ${hp} health remaining. Be mysterious.`,
        });
        return response.text.trim();
      } catch (error) {
        console.error("Gemini Text Error:", error);
        return "The shadows deepen around you.";
      }
    };

    const generateItemImage = async (itemName) => {
      if (!ai) return null;

      try {
        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash-image', 
          contents: {
            parts: [
              {
                text: `A pixel art icon of a ${itemName}, dark dungeon fantasy style, transparent background, 64x64 resolution.`
              }
            ]
          }
        });

        for (const part of response.candidates?.[0]?.content?.parts || []) {
           if (part.inlineData) {
             return `data:image/png;base64,${part.inlineData.data}`;
           }
        }
        return null;
      } catch (error) {
        console.error("Gemini Image Error:", error);
        return null;
      }
    };

    // --- MAZE GENERATOR ---
    const DX = { [Direction.E]: 1, [Direction.W]: -1, [Direction.N]: 0, [Direction.S]: 0 };
    const DY = { [Direction.E]: 0, [Direction.W]: 0, [Direction.N]: -1, [Direction.S]: 1 };
    const OPPOSITE = { [Direction.E]: Direction.W, [Direction.W]: Direction.E, [Direction.N]: Direction.S, [Direction.S]: Direction.N };

    const generateMaze = (width, height) => {
      const grid = [];
      for (let y = 0; y < height; y++) {
        const row = [];
        for (let x = 0; x < width; x++) {
          row.push({
            x,
            y,
            walls: 0,
            item: ItemType.Empty,
            seen: false,
            visible: false,
          });
        }
        grid.push(row);
      }

      const visited = new Set();
      const stack = [];
      const startX = 0;
      const startY = 0;
      
      stack.push({ x: startX, y: startY });
      visited.add(`${startX},${startY}`);

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const { x, y } = current;

        const neighbors = [];
        [Direction.N, Direction.S, Direction.E, Direction.W].forEach(dir => {
          const nx = x + DX[dir];
          const ny = y + DY[dir];
          if (nx >= 0 && ny >= 0 && nx < width && ny < height && !visited.has(`${nx},${ny}`)) {
            neighbors.push(dir);
          }
        });

        if (neighbors.length > 0) {
          const dir = neighbors[Math.floor(Math.random() * neighbors.length)];
          const nx = x + DX[dir];
          const ny = y + DY[dir];

          grid[y][x].walls |= dir;
          grid[ny][nx].walls |= OPPOSITE[dir];

          visited.add(`${nx},${ny}`);
          stack.push({ x: nx, y: ny });
        } else {
          stack.pop();
        }
      }

      const placeItem = (type, count) => {
        let placed = 0;
        let attempts = 0;
        while (placed < count && attempts < 1000) {
          attempts++;
          const rx = Math.floor(Math.random() * width);
          const ry = Math.floor(Math.random() * height);
          if ((rx !== 0 || ry !== 0) && grid[ry][rx].item === ItemType.Empty) {
            grid[ry][rx].item = type;
            placed++;
          }
        }
      };

      const area = width * height;
      placeItem(ItemType.Exit, 1);
      placeItem(ItemType.Score, Math.floor(area * 0.05));
      placeItem(ItemType.Health, Math.floor(area * 0.03));
      placeItem(ItemType.Hazard, Math.floor(area * 0.04));
      placeItem(ItemType.Weapon, Math.floor(area * 0.02));

      grid[0][0].item = ItemType.Start;
      return grid;
    };

    // --- COMPONENTS ---

    const MazeCell = React.memo(({ cell, customAssets }) => {
      const { walls, item, seen, visible } = cell;

      const baseClasses = "relative box-border transition-colors duration-300 flex items-center justify-center select-none overflow-hidden w-full h-full";
      
      let visualClasses = "";
      if (!seen) {
        visualClasses = "bg-slate-950 border-transparent z-0"; 
      } else if (seen && !visible) {
        visualClasses = "bg-slate-900 border-slate-800/50 z-0";
      } else {
        visualClasses = "bg-slate-800 border-indigo-500/50 shadow-[inset_0_0_15px_rgba(0,0,0,0.5)] z-10";
      }

      const borderStyles = {};
      const wallColor = visible ? '#64748b' : (seen ? '#334155' : 'transparent');
      const wallWidth = '1px';

      if (seen) {
        if (!(walls & Direction.N)) borderStyles.borderTop = `${wallWidth} solid ${wallColor}`;
        if (!(walls & Direction.E)) borderStyles.borderRight = `${wallWidth} solid ${wallColor}`;
        if (!(walls & Direction.S)) borderStyles.borderBottom = `${wallWidth} solid ${wallColor}`;
        if (!(walls & Direction.W)) borderStyles.borderLeft = `${wallWidth} solid ${wallColor}`;
      }

      const renderContent = () => {
        if (!seen) return null;

        if (item !== ItemType.Empty && item !== ItemType.Start) {
          const assetUrl = customAssets[item];
          
          if (assetUrl) {
             return (
                 <img src={assetUrl} alt={ITEMS_CONFIG[item].name} className={`w-[70%] h-[70%] object-contain ${!visible ? 'opacity-30 grayscale' : ''}`} />
             );
          }

          if (item === ItemType.Hazard) {
              return <Skull className={`w-[60%] h-[60%] text-green-600 ${!visible ? 'opacity-30' : ''}`} />;
          }

          return (
            <span className={`text-lg sm:text-xl ${ITEMS_CONFIG[item].color} ${!visible ? 'opacity-30 grayscale' : ''}`}>
              {ITEMS_CONFIG[item].char}
            </span>
          );
        }
        return null;
      };

      return (
        <div 
          className={`${baseClasses} ${visualClasses}`} 
          style={borderStyles}
        >
          {renderContent()}
        </div>
      );
    });

    const createInitialState = (level) => {
      const config = LEVEL_CONFIG[level] || LEVEL_CONFIG[4];
      return {
        level,
        hp: 10,
        score: 0,
        bag: [],
        playerPos: { x: 0, y: 0 },
        grid: generateMaze(config.w, config.h),
        width: config.w,
        height: config.h,
        gameOver: false,
        messageLog: ["Welcome to the Nebula Maze. Find the Exit."],
      };
    };

    // --- MAIN APP COMPONENT ---
    function App() {
      const [gameState, setGameState] = useState(() => createInitialState(1));
      const [flavorText, setFlavorText] = useState("Enter the darkness...");
      const [customAssets, setCustomAssets] = useState({});
      const [isGenerating, setIsGenerating] = useState(false);
      const [showStats, setShowStats] = useState(false);
      
      const touchStart = useRef(null);
      const scrollRef = useRef(null);
      const [scoreHistory, setScoreHistory] = useState([{step: 0, score: 0}]);

      useEffect(() => {
        if (scrollRef.current) {
          scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }
      }, [gameState.messageLog]);

      // Fog of War Logic
      const updateVisibility = useCallback((state) => {
        const { playerPos, grid, width, height } = state;
        const newGrid = grid.map(row => row.map(cell => ({ ...cell, visible: false })));

        const queue = [];
        queue.push({ x: playerPos.x, y: playerPos.y, dist: 0 });

        const visited = new Set();
        visited.add(`${playerPos.x},${playerPos.y}`);

        newGrid[playerPos.y][playerPos.x].visible = true;
        newGrid[playerPos.y][playerPos.x].seen = true;

        while (queue.length > 0) {
          const { x, y, dist } = queue.shift();
          if (dist >= VISIBILITY_RADIUS) continue;

          const currentCell = newGrid[y][x];

          [Direction.N, Direction.S, Direction.E, Direction.W].forEach(dir => {
            if (currentCell.walls & dir) {
              const nx = x + DX[dir];
              const ny = y + DY[dir];

              if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                const key = `${nx},${ny}`;
                if (!visited.has(key)) {
                  visited.add(key);
                  newGrid[ny][nx].visible = true;
                  newGrid[ny][nx].seen = true;
                  queue.push({ x: nx, y: ny, dist: dist + 1 });
                }
              }
            }
          });
        }
        return newGrid;
      }, []);

      useEffect(() => {
        setGameState(prev => ({
          ...prev,
          grid: updateVisibility(prev)
        }));
        generateFlavorText(gameState.level, gameState.hp).then(setFlavorText);
      }, [gameState.level]); // updateVisibility is constant, so omitted

      const handleGenerateAssets = async () => {
        if (isGenerating) return;
        setIsGenerating(true);
        setGameState(prev => ({ ...prev, messageLog: [...prev.messageLog, "Summoning allied spirits..."] }));

        const typesToGen = [ItemType.Health, ItemType.Score, ItemType.Hazard, ItemType.Weapon, ItemType.Exit];
        const newAssets = { ...customAssets };

        for (const type of typesToGen) {
          if (!newAssets[type]) {
             const url = await generateItemImage(type);
             if (url) newAssets[type] = url;
          }
        }

        setCustomAssets(newAssets);
        setIsGenerating(false);
        setGameState(prev => ({ ...prev, messageLog: [...prev.messageLog, "Visuals updated."] }));
      };

      const move = useCallback((dx, dy) => {
        if (gameState.gameOver) return;

        setGameState(prev => {
          const { playerPos, grid, width, height, hp, score, bag } = prev;
          const targetX = playerPos.x + dx;
          const targetY = playerPos.y + dy;

          if (targetX < 0 || targetX >= width || targetY < 0 || targetY >= height) {
            playSound('bump');
            return prev;
          }

          const currentCell = grid[playerPos.y][playerPos.x];
          
          let moveAllowed = false;
          if (dy === -1 && (currentCell.walls & Direction.N)) moveAllowed = true;
          if (dy === 1 && (currentCell.walls & Direction.S)) moveAllowed = true;
          if (dx === 1 && (currentCell.walls & Direction.E)) moveAllowed = true;
          if (dx === -1 && (currentCell.walls & Direction.W)) moveAllowed = true;

          if (!moveAllowed) {
             playSound('bump');
             return { ...prev, messageLog: [...prev.messageLog, "Blocked."] };
          }

          playSound('step');

          let newHp = hp;
          let newScore = score;
          let newBag = [...bag];
          const targetCell = grid[targetY][targetX];
          let newItem = targetCell.item;
          const newLog = [...prev.messageLog];
          let levelComplete = false;

          if (newItem !== ItemType.Empty && newItem !== ItemType.Start) {
             switch(newItem) {
               case ItemType.Health:
                 newHp = Math.min(newHp + 2, 20);
                 newLog.push("Found Health (+2 HP)");
                 playSound('pickup');
                 newItem = ItemType.Empty;
                 break;
               case ItemType.Score:
                 newScore += 50;
                 newLog.push("Found Gem (+50 Score)");
                 playSound('pickup');
                 newItem = ItemType.Empty;
                 break;
               case ItemType.Weapon:
                 newBag.push(ItemType.Weapon);
                 newLog.push("Equipped Dagger");
                 playSound('pickup');
                 newItem = ItemType.Empty;
                 break;
               case ItemType.Hazard:
                 if (newBag.includes(ItemType.Weapon)) {
                   newLog.push("Slayed Snake with Dagger!");
                   newScore += 20;
                   playSound('hazard'); 
                   newBag = newBag.filter(i => i !== ItemType.Weapon);
                 } else {
                   newHp -= 3;
                   newLog.push("Bitten by Snake! (-3 HP)");
                   playSound('hazard'); 
                 }
                 newItem = ItemType.Empty;
                 break;
               case ItemType.Exit:
                 playSound('levelUp');
                 levelComplete = true;
                 break;
             }
          }

          if (newHp <= 0) {
            playSound('die');
            return { ...prev, hp: 0, gameOver: true, messageLog: [...newLog, "GAME OVER"] };
          }

          if (levelComplete) {
             const nextLevel = prev.level + 1;
             const newState = createInitialState(nextLevel);
             newState.score = newScore;
             newState.bag = newBag;
             newState.hp = newHp;
             newState.messageLog = [`Level ${nextLevel} started.`];
             setScoreHistory(h => [...h, { step: h.length, score: newScore }]);
             const visibleGrid = updateVisibility(newState);
             return { ...newState, grid: visibleGrid };
          }

          const newGrid = [...grid];
          newGrid[targetY] = [...grid[targetY]];
          newGrid[targetY][targetX] = { ...targetCell, item: newItem };

          const partialState = {
            ...prev,
            playerPos: { x: targetX, y: targetY },
            hp: newHp,
            score: newScore,
            bag: newBag,
            grid: newGrid,
            messageLog: newLog,
          };

          const finalGrid = updateVisibility(partialState);
          
          if (newScore !== score) {
             setScoreHistory(h => [...h, { step: h.length, score: newScore }]);
          }

          return { ...partialState, grid: finalGrid };
        });
      }, [gameState.gameOver, updateVisibility]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
            e.preventDefault();
          }
          switch(e.key) {
            case 'ArrowUp': case 'w': move(0, -1); break;
            case 'ArrowDown': case 's': move(0, 1); break;
            case 'ArrowLeft': case 'a': move(-1, 0); break;
            case 'ArrowRight': case 'd': move(1, 0); break;
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [move]);

      const handleTouchStart = (e) => {
        touchStart.current = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
      };

      const handleTouchEnd = (e) => {
        if (!touchStart.current) return;
        
        const touchEnd = {
          x: e.changedTouches[0].clientX,
          y: e.changedTouches[0].clientY
        };

        const diffX = touchEnd.x - touchStart.current.x;
        const diffY = touchEnd.y - touchStart.current.y;
        const absX = Math.abs(diffX);
        const absY = Math.abs(diffY);
        const threshold = 30; 

        if (Math.max(absX, absY) > threshold) {
          if (absX > absY) {
            move(diffX > 0 ? 1 : -1, 0);
          } else {
            move(0, diffY > 0 ? 1 : -1);
          }
        }
        touchStart.current = null;
      };

      const { width, height, grid, playerPos, level, hp, score, gameOver, messageLog, bag } = gameState;

      return (
        <div className="min-h-screen bg-slate-950 flex flex-col items-center justify-center p-4 font-sans relative select-none">
          
          <header className="w-full max-w-2xl flex items-center justify-between mb-4 bg-slate-900/80 p-4 rounded-xl border border-slate-800 backdrop-blur-sm sticky top-2 z-50 shadow-lg">
            <div className="flex gap-4">
              <div className="flex flex-col">
                <span className="text-xs text-slate-400 uppercase tracking-widest">Level</span>
                <span className="text-2xl font-bold text-white">{level}</span>
              </div>
              <div className="flex flex-col">
                <span className="text-xs text-slate-400 uppercase tracking-widest">HP</span>
                <span className={`text-2xl font-bold ${hp < 4 ? 'text-red-500 animate-pulse' : 'text-emerald-400'}`}>{hp}</span>
              </div>
              <div className="flex flex-col">
                <span className="text-xs text-slate-400 uppercase tracking-widest">Score</span>
                <span className="text-2xl font-bold text-cyan-400">{score}</span>
              </div>
            </div>

            <div className="flex gap-2">
               <button 
                 onClick={() => setShowStats(!showStats)} 
                 className="p-2 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition"
                 title="Toggle Stats"
                >
                 <MapIcon size={20} className="text-slate-300" />
               </button>
               <button 
                 onClick={handleGenerateAssets} 
                 disabled={isGenerating}
                 className="p-2 bg-indigo-900/50 hover:bg-indigo-800 rounded-lg border border-indigo-500/30 transition flex items-center gap-2"
                 title="Generate AI Assets"
                >
                 <Sparkles size={20} className={isGenerating ? "animate-spin text-yellow-400" : "text-yellow-400"} />
                 <span className="hidden sm:inline text-xs font-semibold text-indigo-200">AI Visuals</span>
               </button>
            </div>
          </header>

          <div className="w-full max-w-2xl text-center mb-2 h-6 text-sm text-slate-400 italic">
            {flavorText}
          </div>

          <div className="flex gap-4 w-full max-w-5xl justify-center items-start flex-wrap lg:flex-nowrap">
            
            <div 
               className="relative p-1 bg-slate-900 rounded-lg border-4 border-slate-800 shadow-2xl overflow-hidden touch-none"
               onTouchStart={handleTouchStart}
               onTouchEnd={handleTouchEnd}
            >
              {gameOver && (
                <div className="absolute inset-0 z-50 bg-black/80 flex flex-col items-center justify-center backdrop-blur-sm">
                  <AlertTriangle size={64} className="text-red-500 mb-4" />
                  <h2 className="text-4xl font-bold text-white mb-2">YOU DIED</h2>
                  <p className="text-slate-400 mb-6">Score: {score} | Level: {level}</p>
                  <button 
                    onClick={() => setGameState(createInitialState(1))}
                    className="px-6 py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-lg flex items-center gap-2 transition"
                  >
                    <RefreshCw size={20} /> Try Again
                  </button>
                </div>
              )}

              <div 
                className="grid gap-0 bg-black relative"
                style={{
                  gridTemplateColumns: `repeat(${width}, minmax(0, 1fr))`,
                  width: width > 15 ? 'min(90vw, 600px)' : 'min(90vw, 400px)',
                }}
              >
                {grid.map((row) => 
                  row.map((cell) => (
                    <div key={`${cell.x}-${cell.y}`} className="aspect-square">
                      <MazeCell 
                        cell={cell} 
                        customAssets={customAssets}
                      />
                    </div>
                  ))
                )}

                {!gameOver && (
                  <div 
                    className="absolute z-40 transition-all duration-200 ease-out flex items-center justify-center pointer-events-none"
                    style={{
                      left: `${(playerPos.x / width) * 100}%`,
                      top: `${(playerPos.y / height) * 100}%`,
                      width: `${(1 / width) * 100}%`,
                      height: `${(1 / height) * 100}%`,
                    }}
                  >
                     <div className="w-[50%] h-[50%] bg-blue-600 rounded-full flex items-center justify-center shadow-[0_0_15px_#3b82f6]">
                        <User size="80%" color="white" strokeWidth={3} />
                     </div>
                  </div>
                )}
              </div>
            </div>

            <div className="w-full max-w-md flex flex-col gap-4">
               {showStats && (
                 <div className="bg-slate-900/90 p-4 rounded-xl border border-slate-800 h-48">
                   <h3 className="text-xs text-slate-400 uppercase tracking-widest mb-2">Score History</h3>
                   <ResponsiveContainer width="100%" height="100%">
                     <LineChart data={scoreHistory}>
                       <XAxis dataKey="step" hide />
                       <YAxis hide domain={['dataMin', 'dataMax']} />
                       <Tooltip 
                         contentStyle={{ backgroundColor: '#0f172a', border: '1px solid #334155', color: '#fff' }}
                         itemStyle={{ color: '#22d3ee' }}
                       />
                       <Line type="monotone" dataKey="score" stroke="#22d3ee" strokeWidth={2} dot={false} />
                     </LineChart>
                   </ResponsiveContainer>
                 </div>
               )}

               <div className="bg-slate-900/90 p-4 rounded-xl border border-slate-800">
                 <h3 className="text-xs text-slate-400 uppercase tracking-widest mb-3 flex items-center gap-2">
                   <Shield size={14} /> Inventory
                 </h3>
                 <div className="flex gap-2 flex-wrap min-h-[40px]">
                   {bag.length === 0 && <span className="text-slate-600 text-sm italic">Empty...</span>}
                   {bag.map((item, i) => (
                     <div key={i} className="p-2 bg-slate-800 rounded border border-slate-700" title={item}>
                       {item === ItemType.Weapon ? 'üó°Ô∏è' : 'üì¶'}
                     </div>
                   ))}
                 </div>
               </div>

               <div className="bg-slate-900/90 rounded-xl border border-slate-800 overflow-hidden flex flex-col h-64 lg:h-96">
                 <div className="p-3 bg-slate-800 border-b border-slate-700">
                   <h3 className="text-xs text-slate-400 uppercase tracking-widest">Log</h3>
                 </div>
                 <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-2 scrollbar-hide">
                    {messageLog.map((msg, i) => (
                      <div key={i} className={`text-sm ${msg.includes("GAME OVER") ? "text-red-500 font-bold" : "text-slate-300"} border-l-2 ${msg.includes("Found") ? "border-cyan-500 pl-2" : "border-slate-700 pl-2"}`}>
                        {msg}
                      </div>
                    ))}
                 </div>
               </div>
               
               <div className="text-center text-xs text-slate-500 lg:hidden">
                  Swipe to move
               </div>
            </div>
          </div>
        </div>
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  </script>
  <div id="root"></div>
</body>
</html>